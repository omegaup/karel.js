<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8">
  <title>La sentencia define-nueva-instruccion/como &nbsp;</title>
</head>
<body style="background-image: url(./workbook.gif);">
  <center>
    <h2><a id="inicio"
       name="inicio"></a>Recursividad&nbsp;</h2>
  </center>
  <p>Hemos llegado al &uacute;ltimo tema, y no por eso el menos importante, de hecho, es el tema m&aacute;s
  complicado que veremos aqui, y es muy &uacute;til no solo para Karel, sino para resolver cualquier
  problema. Debido a la complejidad del tema, se han creado 5 subtemas:</p>
  <ol>
    <li>
      <a href="#fundamentos">Fundamentos</a>
    </li>
    <li>
      <a href="#definicion">Definici&oacute;n</a>
    </li>
    <li>
      <a href="#recsimple">Recursividad simple</a>
    </li>
    <li>
      <a href="#recparam">Recursividad con par&aacute;metros</a>
    </li>
    <li>
      <a href="#recmix">Recursividad mixta</a>
    </li>
  </ol>
  <h2><a id="fundamentos"
     name="fundamentos">Fundamentos</a></h2>
  <p>Empecemos. &iquest;Te has preguntado alguna vez qu&eacute; sucede cu&aacute;ndo llamas a una instrucci&oacute;n que tu
  creaste? Como te habr&aacute;s dado cuenta, se ejecuta la instrucci&oacute;n que le pediste y luego continua en
  el lugar en donde se qued&oacute;. Pero en realidad, &iquest;c&oacute;mo hace eso la computadora? Pues bien, la
  computadora tiene una cosa que se llama "pila de llamadas", cuando un programa se ejecuta y
  encuentra una instrucci&oacute;n, se guarda en la pila en que lugar se qued&oacute;, entonces ejecuta la
  instrcci&oacute;n que le pediste y al terminar la instrucci&oacute;n, revisa en la pila en donde estaba
  anteriormente, para continuar en ese lugar. &iquest;Muy enredado? Mira este dibujo:</p>
  <p align="center"><img src="javaPila.gif" /></p>
  <p>Espero haya quedado claro, ya que esto es el punto crucial de la recursividad. Ahora que
  sabemos como funciona el llamado a procedimientos o instrucciones. Definamos lo que es
  recursividad.</p>
  <h3><a href="#inicio">Subir</a></h3>
  <h2><a id="definicion"
     name="definicion">Definici&oacute;n</a></h2>
  <p>Una instrucci&oacute;n recursiva, es aquella que en alg&uacute;n momento, se llama as&iacute; misma. Por ejemplo,
  puedes revisar en libros y en muchos otros lados, la definici&oacute;n recursiva del factorial:</p>
  <p>factorial(1) = 1</p>
  <p>factorial(n) = n * factorial(n - 1)</p>
  <p>Como puedes ver, para saber el factorial de un n&uacute;mero, necesitas saber el factorial del n&uacute;mero
  anterior. All&iacute; est&aacute; la recursividad.</p>
  <p>Toda instrucci&oacute;n recursiva, consta de dos partes:</p>
  <dl>
    <dt><strong>1.- Base</strong></dt>
    <dd><br />
    Es un valor fijo al que eventualmente, la recursi&oacute;n debe de llegar, normalmente, es un valor
    pequentilde;o y no demostrable. Por ejemplo, factorial de 1, es 1, y no se puede demostrar, adem&aacute;s,
    si quieres calcular el factorial de cualquier n&uacute;mero, eventualmente, debes de saber el
    factorial de 1.</dd>
    <dt>&nbsp;</dt>
    <dt>&nbsp;</dt>
    <dt><strong><br />
    2.- Recursi&oacute;n</strong></dt>
    <dd><br />
    Consiste en la parte en donde la instrucci&oacute;n se llama as&iacute; misma, adem&aacute;s de efectuar algunas
    operaciones con el resultado. Por ejemplo, para el factorial de 3, se calcula el factorial de 2
    y eso se multiplica por 3.</dd>
  </dl>
  <p>Ahora que sabes que es recursividad, intenta hacer la definici&oacute;n recursiva de la serie de
  Fibonacci, la cual dice que sus primeros dos elementos (1 y 2) son 1, y para cualquier otro
  n&uacute;mero de Fibonacci, se debe sumar el Fibonacci de los dos n&uacute;meros anteriores, Por ejemplo:
  Fibonacci(3) = 2, Fibonacci(5) = 5.</p>
  <p>Pasemos de lleno a la recursividad en Karel.</p>
  <h3><a href="#inicio">Subir</a></h3>
  <h2><a id="recsimple"
     name="recsimple">Recursividad simple</a></h2>
  <p>Intentemos ahora llamar a una instrucci&oacute;n desde s&iacute; misma, recordemos que debe de tener una
  base y una definici&oacute;n recursiva, &iquest;te parece bien que la base sea si el frente esta bloqueado
  termina?, &iquest;y te parece bien que si no avance una casilla y entonces se llame asi misma?,
  &iexcl;Hag&aacute;moslo!</p>
  <p>...</p>
  <p>void recursiva () {</p>
  <p>&nbsp;&nbsp;&nbsp;if (frontIsClear) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recursiva();</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>}</p>
  <p>...</p>
  <p>Nota que en Karel es imposible decirle que termine la instruccion, as&iacute; que mejor invertimos la
  condici&oacute;n y avanzamos si el frente est&aacute; libre, &iexcl;es otra forma de poner la base!, por que, en
  otras palabras, la base es lo que hace que la recursi&oacute;n termine y no sea infinita. Nota tambi&eacute;n
  que en este caso las operaciones que hacemos son solamente "move();". Algo diferente al factorial
  &iquest;no?</p>
  <p>&iquest;Qu&eacute; crees que haga est&eacute; c&oacute;digo? Ponlo en el Simulador Karel y adivina...</p>
  <p>&iexcl;As&iacute; es! Karel avanzar&aacute; mientras el frente este libre. Entonces te preguntar&aacute;s &iquest;no ser&iacute;a mejor
  un ciclo mientras? Y la respuesta es: si solamente quieres hacer eso, s&iacute;, sin embargo, &iquest;que tal
  si quieres contar con zumbadores cuantos pasos avanzaste? &iexcl;A verdad! Si queremos hacer eso,
  debemos agregarle una l&iacute;nea a nuestro c&oacute;digo:</p>
  <p>...</p>
  <p>void recursiva () {</p>
  <p>&nbsp;&nbsp;&nbsp;if (frontIsClear) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recursiva();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putbeeper();</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>}</p>
  <p>...</p>
  <p>Ahora pru&eacute;balo.</p>
  <p>&iexcl;Wow! &iexcl;Sorprendente! &iquest;Por qu&eacute; funciona?</p>
  <p>Si recuerdas la secci&oacute;n de fundamentos, cada vez que se llama una instrucci&oacute;n, la siguiente
  instrucci&oacute;n se guarda en la pila de llamadas, como se va a llamar exactamente el n&uacute;mero de veces
  que avanzaste, cuando la recursividad termine al llegar a la base, va a sacar una por una las
  instrucciones que siguen, y las que siguen siempre ser&aacute;n "putbeeper();". En este ejemplo, solo
  hay una instrucci&oacute;n antes y despu&eacute;s de las llamadas recursivas, pero puede haber much&iacute;simas
  m&aacute;s.</p>
  <p>Si a&uacute;n no lo entiendes, trata de simular la pila de llamadas de la misma forma que est&aacute; en la
  imagen.</p>
  <p><strong>Ejercicio 12</strong>: &iquest;Recuerdas el problema del peri&oacute;dico del Ejercicio 2? Ahora
  imagina que el peri&oacute;dico est&aacute; en la posici&oacute;n 1,1 y que la casa de Karel, puede estar ubicada en
  cualquier posici&oacute;n del mundo, eso s&iacute;, con la misma orientaci&oacute;n y forma. Haz un programa que haga
  que Karel lleve el peri&oacute;dico a su sala. &iexcl;Usa recursividad! Recuerda, piensa en que momento la
  recursividad termina (BASE) y si hay que hacer algo en ese momento, luego piensa en la llamada
  recursiva, y las operaciones que van a ir antes, y las que van a ir despu&eacute;s (las que se van a
  guardar en la pila).</p>
  <h3><a href="#inicio">Subir</a></h3>
  <h2><a id="recparam"
     name="recparam">Recursividad con par&aacute;metros</a><br />
  <br /></h2>
  <p>&iquest;Recuerdas los par&aacute;metros? &iquest;Recuerdas las funciones pred() y succ()? &iquest;Que pasar&iacute;a si a una
  instrucci&oacute;n con par&aacute;mtro la llamaramos usando pred() o succ()?</p>
  <p>Todo esto, en Karel es posible, definamos una instrucci&oacute;n con par&aacute;metros y volv&aacute;mosla
  recursiva usando succ():</p>
  <p>...</p>
  <p>void recursiva2 (n) {</p>
  <p>&nbsp;&nbsp;&nbsp;if (frontIsClear) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recursiva2 ( succ (n) );</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>&nbsp;&nbsp;&nbsp;else {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate(n) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putbeeper();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>}</p>
  <p>...</p>
  <p>Este c&oacute;digo hace exactamente lo mismo que el de la secci&oacute;n anterior, con la diferencia de que
  la complejidad que exist&iacute;a en la pila de llamadas es eliminada, y colocada como una instrucci&oacute;n
  base. En cada paso de la recursi&oacute;n, se aumenta uno, y cuando llegas a la base, tiene un n&uacute;mero
  que tal vez pudas usar para tu beneficio. No te olvides que tambi&eacute;n puedes usar la funci&oacute;n pred()
  y iszero() y que en la llamada recursiva puedes llamarla con el par&aacute;metro sin modficar.</p>
  <p>Como punto importante, hay que destacar que en la pila de llamdas, adem&aacute;s de la instrucci&oacute;n
  que sigue, tambi&eacute;n se guarda el valor actual del par&aacute;metro.</p>
  <p><strong>Ejercicio 13</strong>: Realiza el Ejercicio 12 pero con Recursividad con
  par&aacute;metros.</p>
  <p><strong>Ejercicio 14</strong>: Realiza una instrucci&oacute;n que avance a Karel tantas veces como
  zumbadores tenga en su mochila utilizando Recursividad con par&aacute;metros, NO se vale usar un ciclo
  mientras.</p>
  <h3><a href="#inicio">Subir</a></h3>
  <h2><a id="recmix"
     name="recmix">Recursividad mixta</a></h2>
  <p>Si ya dominas los dos tipos de recursividad anteriores, esto ser&aacute; muy f&aacute;cil para ti, ya que la
  recursividad mixta no es m&aacute;s que usar los dos tipos de recursividad al mismo tiempo.</p>
  <p>Veamos el siguiente problema:</p>
  <div align="center">
    <p><img src="image33.jpg" /></p>
  </div>
  <p>Teniendo un mundo como el de arriba y con zumbadores infinitos en la mochila, coloca en 1,1 el
  resultado de la multiplicaci&oacute;n.</p>
  <p>Este es uno de los problemas m&aacute;s cl&aacute;sicos de recursividad mixta, sin ella la complejidad del
  problema ser&iacute;a muy elevada.</p>
  <p>Para este problema usaremos dos instrucciones, uno con recursividad simple y el otro con
  par&aacute;metro.</p>
  <p>La mec&aacute;nica de soluci&oacute;n es la siguiente: Se van a tomar todos los zumbadores de una posici&oacute;n
  con recursividad con par&aacute;metros, para que al llegar a la base, el par&aacute;metro tenga el n&uacute;mero de
  zumbadores que hay en dicha posici&oacute;n, posteriormente, ese n&uacute;mero se pasa como par&aacute;metro a la
  instrucci&oacute;n recursiva simple (si, aunque la recursividad es simple, tambi&eacute;n tiene par&aacute;metro), y
  en cada paso, se le va a llamar recursivamente con el mismo par&aacute;metro, de esa forma, en la pila
  de llamadas, el par&aacute;metro va a estar tantas veces como zumbadores haya en la segunda posici&oacute;n, y
  vuala. Tal vez quede m&aacute;s claro si ves las instrucciones y las sigues paso a paso en Karel.</p>
  <p>...</p>
  <p>void multiplica (n) {</p>
  <p>&nbsp;&nbsp;&nbsp;if (nextToABeeper) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickbeeper();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiplica(n);</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate (n) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putbeeper();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>&nbsp;&nbsp;&nbsp;else {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;veAlInicio();</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>}</p>
  <p>void cuenta (n) {</p>
  <p>&nbsp;&nbsp;&nbsp;if (nextToABeeper) {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickbeeper();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cuenta( sucede (n) );</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>&nbsp;&nbsp;&nbsp;else {</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiplica (n);</p>
  <p>&nbsp;&nbsp;&nbsp;}</p>
  <p>}</p>
  <p>...</p>
  <p>Esta casi completa, pero le falta implementar la instrucci&oacute;n veAlInicio (que debe ser de lo
  m&aacute;s trivial) y el posicionamiento inicial, tal vez en un principio no entiendas bien, revisa el
  c&oacute;digo paso a paso hasta que lo comprendas, &iexcl;Suerte!</p>
  <p><strong>Ejercicio 15</strong>: Teniendo un mundo como el de abajo:</p>
  <div align="center"><img src="image34.jpg" /></div>
  <p>en donde puede haber cualquier cantidad de calles y cualquier ancho en las avenidas (siempre
  cerrado el circuito y sin "islas" o bifurcaciones),deje en la esquina izquierda m&aacute;s inferior (2,1
  en el ejemplo), tantos zumbadores como n&uacute;mero de calles de ancho 1 que hay, Karel lleva infinitos
  zumbadores en su mochila. En resultado del ejemplo es 3.</p>
  <p>En este problema se usan casi todos los temas vistos en el curso, emplealos y resu&eacute;lvelo.</p>
  <p>&nbsp;</p>
  <p>Hemos llegado al fin del curso, ahora debes ser capaz de participar en la Olimpiada Mexicana
  de Informatica, no olvides seguir resolviendo problemas para mejorar siempre tus habilidades,
  puedes encontrar ligas a las p&aacute;ginas en donde hay problemas en la p&aacute;gina principal de la OMI.</p>
  <p>&iexcl;SUERTE!</p>
  <h3><a href="#inicio">Subir</a></h3>
  <center>
    <h2>Recursividad</h2>
    <h2 align="left"><a href="Karel.html">Regresar</a></h2>
  </center>
</body>
</html>
