<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8">
  <title>Condiciones que puede detectar Karel</title>
</head>
<body style="background-image: url('workbook.gif')">
  <center>
    <h2>Condiciones que puede detectar Karel&nbsp;</h2>
  </center>Date cuenta de que la condici&oacute;n facingSouth, en el fragmento de programa de la p&aacute;gina
  del if &nbsp;
  <p></p>...
  <p>if (facingSouth) {</p>
  <p>&nbsp;&nbsp; turnleft();</p>
  <p>&nbsp;&nbsp; turnleft();</p>
  <p>&nbsp;&nbsp; turnleft();</p>
  <p>}</p>
  <p>...</p>
  <p>La condici&oacute;n es una funci&oacute;n de la situaci&oacute;n actual de Karel, a medida que se ejecuta el
  programa. Si Karel est&aacute; actualmente orientado hacia el Sur, el valor de la funci&oacute;n facingSouth
  ser&aacute; verdadero, y el conjunto de sentencias entre las llaves "{ }", se ejecutar&aacute;. De otra
  manera,&nbsp; el valor facingSouth ser&aacute; falso y el bloque de sentencias se saltar&aacute;. Karel
  comprende cualquier funci&oacute;n booleana que comprueba su situaci&oacute;n actual. Aqu&iacute; hay un listado:</p>
  <p>&nbsp;</p><strong>
  <center>
    <table border="2">
      <tr>
        <td width="108"><strong>frontIsClear</strong></td>
        <td width="203"><strong>nextToABeeper</strong></td>
        <td width="142"><strong>facingEast</strong></td>
      </tr>
      <tr>
        <td><strong>frontIsBloc</strong><strong>ked</strong></td>
        <td><strong>notNextToABeeper</strong></td>
        <td><strong>facingWest</strong></td>
      </tr>
      <tr>
        <td><strong>leftIsClear</strong></td>
        <td><strong>anyBeepersInBeeperBag</strong></td>
        <td><strong>not</strong><strong>FacingNorth</strong></td>
      </tr>
      <tr>
        <td><strong>leftIs</strong><strong>Blocked</strong></td>
        <td><strong>noBeepersInBeeperBag</strong></td>
        <td><strong>notFacingSouth</strong></td>
      </tr>
      <tr>
        <td><strong>rightIsC</strong><strong>lear</strong></td>
        <td><strong>fa</strong><strong>cingNorth</strong></td>
        <td><strong>notFacingEast</strong></td>
      </tr>
      <tr>
        <td><strong>rightIs</strong><strong>Blocked</strong></td>
        <td><strong>facingSouth</strong></td>
        <td><strong>notFacingWe</strong><strong>st</strong></td>
      </tr>
    </table>
  </center></strong> &nbsp;
  <p>"clear" significa que no hay ning&uacute;n muro, mientras que "blocked" significa que hay un muro en
  esa direcci&oacute;n. Karel puede detectar si hay o no alg&uacute;n zumbador en la esquina en la que se
  encuentra actualmente, as&iacute; como detectar si tiene alg&uacute;n zumbador en la mochila o no. Tambi&eacute;n
  tiene una br&uacute;jula para detectar hacia qu&eacute; direcci&oacute;n est&aacute; orientado.</p>
  <p>Por si fuera poco podemos unir dos o m&aacute;s funciones booleanas con los operadores l&oacute;gicos Y, O,
  y NO.</p>
  <p>Podemos ver la s&iacute;ntaxis de los operadores y sus valores con las siguientes tablas:</p>
  <p></p>
  <h3 align="center">Operador y ("&amp;&amp;" )</h3>
  <p align="center">S&iacute;ntaxis: funci&oacute;nBooleana1 &amp;&amp; funci&oacute;nBooleana2</p>
  <p></p>
  <div align="center">
    <table border="2">
      <tr>
        <td width="176"><strong>Valor de la funci&oacute;n 1</strong></td>
        <td width="176"><strong>Valor de la funci&oacute;n 2</strong></td>
        <td width="176"><strong>Resultado final</strong></td>
      </tr>
      <tr>
        <td>falso</td>
        <td>falso</td>
        <td>falso</td>
      </tr>
      <tr>
        <td>falso</td>
        <td>verdadero</td>
        <td>falso</td>
      </tr>
      <tr>
        <td>verdadero</td>
        <td>falso</td>
        <td>falso</td>
      </tr>
      <tr>
        <td>verdadero</td>
        <td>verdadero</td>
        <td>verdadero</td>
      </tr>
    </table>
    <h3 align="center">Operador o ("||")</h3>
    <p align="center">S&iacute;ntaxis: funci&oacute;n-booleana1 || funci&oacute;n-booleana2</p>
    <p></p>
    <div align="center">
      <table border="2">
        <tr>
          <td width="176"><strong>Valor de la funci&oacute;n 1</strong></td>
          <td width="176"><strong>Valor de la funci&oacute;n 2</strong></td>
          <td width="176"><strong>Resultado final</strong></td>
        </tr>
        <tr>
          <td>falso</td>
          <td>falso</td>
          <td>falso</td>
        </tr>
        <tr>
          <td>falso</td>
          <td>verdadero</td>
          <td>verdadero</td>
        </tr>
        <tr>
          <td>verdadero</td>
          <td>falso</td>
          <td>verdadero</td>
        </tr>
        <tr>
          <td>verdadero</td>
          <td>verdadero</td>
          <td>verdadero</td>
        </tr>
      </table>
      <h3 align="center">Operador no ("!")</h3>
      <p align="center">S&iacute;ntaxis: ! funci&oacute;n-booleana</p>
      <p></p>
      <div align="center">
        <table border="2">
          <tr>
            <td width="176"><strong>Valor de la funci&oacute;n</strong></td>
            <td width="176"><strong>Resultado final</strong></td>
          </tr>
          <tr>
            <td>falso</td>
            <td>verdadero</td>
          </tr>
          <tr>
            <td>verdadero</td>
            <td>falso</td>
          </tr>
        </table>
        <p align="left">Los operadores "&amp;&amp;" y "||" se aplican sobre dos funciones y el
        operador "!" solo sobre una. Lo mejor de los operadores l&oacute;gicos es que si ponemos dentro de
        un par de par&eacute;ntesis las funciones con el operador l&oacute;gico, entonces toda la operaci&oacute;n se
        vuelve una funci&oacute;n booleana, por lo que podemos aplicar m&aacute;s operadores l&oacute;gicos sobre ella.
        &iquest;No qued&oacute; claro? Revisa estos ejemplos:</p>
        <p align="center">(facingNorth || facingSouth) &amp;&amp; frontIsClear</p>
        <p align="center">(! (frontIsBlocked &amp;&amp; nextToABeeper)) || facingEast</p>
        <p align="center">! (nextToABeeper &amp;&amp; frontIsClear)</p>
        <p align="left">Ten mucho cuidado de colocar bien los par&eacute;ntesis, ya que si no lo haces, no
        te marcar&aacute; error, pero seguramente har&aacute; algo extrantilde;o que tu no quieres que haga.</p>
      </div>
    </div>
  </div>
  <p>Por ejemplo, si queremos que Karel avance si est&aacute; viendo al norte y el frente est&eacute; libre,
  podemos hacer lo siguiente:<br />
  ...</p>
  <p>if (facingNorth &amp;&amp; frontIsClear) {</p>
  <p>&nbsp;&nbsp;&nbsp;move();</p>
  <p>}</p>
  <p>...</p>
  <p><strong>Ejercicio 3 :</strong> &nbsp; Escribe un programa de Karel que haga que Karel est&eacute;
  orientado al Norte, desde cualquier direcci&oacute;n inicial, y a continuaci&oacute;n se apague. Deber&iacute;a
  terminar en la misma intersecci&oacute;n en la que empez&oacute;.</p>
  <p>&iquest;Alguna sugerencia?</p>
  <p>En un mundo nuevo inserta el ejemplo visto arriba para el caso en que Karel est&aacute; orientado
  hacia el Sur. Pero, &iquest;qu&eacute; ocurre cuando no est&aacute; orientado hacia el Sur?. &iexcl;Podr&iacute;a estar tambi&eacute;n
  orientado hacia el Norte o el Este !. Entonces necesitas dos sentencias <strong>if</strong>
  adicionales, en las cuales se especifique que es lo que debe hacer Karel en esas situaciones.</p>
  <p>Modifica el mundo inicial de Karel para probar cualquiera de las 4 direcciones de inicio, y
  para cada una de ellas vuelve a ejecutar el programa.</p>
  <p>En esta secci&oacute;n hemos visto como usar las sentencias de control para adaptar Karel a cada
  situaci&oacute;n.</p>
  <center>
    <h2>
    <p>Condiciones que puede detectar Karel&nbsp;</p>
    <p align="left"><a href="KarelJAVA.html">Regresar</a></p></h2>
  </center>
</body>
</html>
