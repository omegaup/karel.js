<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title> Condiciones que puede detectar Karel </title>
</head>

<body style="background-image: url('workbook.gif')">
<h2><center>Condiciones que puede detectar Karel  
</center></h2>
Date cuenta de que la condición facingSouth, en el fragmento de programa de la página del if   
<p>
</p>
...<p>
 if (facingSouth) { </p>
<p>
      turnleft();  </p>
<p>
       turnleft();  </p>
<p>
     turnleft();  </p>
<p>
  }</p>
<p>
  ...</p>
<p>
La condición es una función de la situación actual de Karel, a medida que se ejecuta el programa. Si Karel está actualmente orientado hacia el Sur, el valor de la función  facingSouth  será verdadero, y el conjunto de sentencias entre las llaves &quot;{ }&quot;, se ejecutará. De otra manera,  el valor  facingSouth  será falso y el bloque de sentencias se saltará. Karel comprende cualquier función booleana que comprueba su situación actual. Aquí hay un listado:</p>
<p>
   
</p>
<b><center><table border="2">
 <tr>
 	<td width="108"><strong>frontIsClear</strong></td>
 	<td width="203"><strong>nextToABeeper</strong></td>
 	<td width="142"><strong>facingEast</strong></td>
 </tr>
 <tr>
 	<td><strong>frontIsBloc</strong><strong>ked</strong></td>
 	<td><strong>notNextToABeeper</strong></td>
 	<td><strong>facingWest</strong></td>
 </tr>
 <tr>
 	<td><strong>leftIsClear</strong></td>
 	<td><strong>anyBeepersInBeeperBag</strong></td>
 	<td><strong>not</strong><strong>FacingNorth</strong></td>
 </tr>
 <tr>
 	<td><strong>leftIs</strong><strong>Blocked</strong></td>
 	<td><strong>noBeepersInBeeperBag</strong></td>
 	<td><strong>notFacingSouth</strong></td>
 </tr>
 <tr>
 	<td><strong>rightIsC</strong><strong>lear</strong></td>
 	<td><strong>fa</strong><strong>cingNorth</strong></td>
 	<td><strong>notFacingEast</strong></td>
 </tr>
 <tr>
 	<td><strong>rightIs</strong><strong>Blocked</strong></td>
 	<td><strong>facingSouth</strong></td>
 	<td><strong>notFacingWe</strong><strong>st</strong></td>
 </tr>
 </table></center>
</b>&nbsp;<p>
 
"clear" significa que no hay ningún muro, mientras que "blocked" significa que hay un muro en esa dirección. Karel puede detectar si hay o no algún zumbador en la esquina en la que se encuentra actualmente, así como detectar si tiene algún zumbador en la mochila o no. También tiene una brújula para detectar hacia qué dirección está orientado.</p>
<p>Por si fuera poco podemos unir dos o m&aacute;s funciones booleanas con los operadores l&oacute;gicos Y, O, y NO. </p>
<p>Podemos ver la s&iacute;ntaxis de los operadores y sus valores con las siguientes tablas:</p>
<p></p>
<h3 align="center">Operador y (&quot;&amp;&amp;&quot; ) </h3>
<p align="center">S&iacute;ntaxis: funci&oacute;nBooleana1 &amp;&amp; funci&oacute;nBooleana2</p>
<p></p>
<div align="center">
  <table border="2">
    <tr>
      <td width="176"><strong>Valor de la funci&oacute;n 1 </strong></td>
      <td width="176"><strong>Valor de la funci&oacute;n 2 </strong></td>
      <td width="176"><strong>Resultado final </strong></td>
    </tr>
    <tr>
      <td>falso</td>
      <td>falso</td>
      <td>falso</td>
    </tr>
    <tr>
      <td>falso</td>
      <td>verdadero</td>
      <td>falso</td>
    </tr>
    <tr>
      <td>verdadero</td>
      <td>falso</td>
      <td>falso</td>
    </tr>
    <tr>
      <td>verdadero</td>
      <td>verdadero</td>
      <td>verdadero</td>
    </tr>
  </table>
  <h3 align="center">Operador o ("||")</h3>
  <p align="center">S&iacute;ntaxis: funci&oacute;n-booleana1 || funci&oacute;n-booleana2</p>
  <p></p>
  <div align="center">
    <table border="2">
      <tr>
        <td width="176"><strong>Valor de la funci&oacute;n 1 </strong></td>
        <td width="176"><strong>Valor de la funci&oacute;n 2 </strong></td>
        <td width="176"><strong>Resultado final </strong></td>
      </tr>
      <tr>
        <td>falso</td>
        <td>falso</td>
        <td>falso</td>
      </tr>
      <tr>
        <td>falso</td>
        <td>verdadero</td>
        <td>verdadero</td>
      </tr>
      <tr>
        <td>verdadero</td>
        <td>falso</td>
        <td>verdadero</td>
      </tr>
      <tr>
        <td>verdadero</td>
        <td>verdadero</td>
        <td>verdadero</td>
      </tr>
    </table>
    <h3 align="center">Operador no (&quot;!&quot;) </h3>
    <p align="center">S&iacute;ntaxis: ! funci&oacute;n-booleana</p>
    <p></p>
    <div align="center">
      <table border="2">
        <tr>
          <td width="176"><strong>Valor de la funci&oacute;n</strong></td>
          <td width="176"><strong>Resultado final </strong></td>
        </tr>
        <tr>
          <td>falso</td>
          <td>verdadero</td>
        </tr>
        <tr>
          <td>verdadero</td>
          <td>falso</td>
        </tr>
      </table>
      <p align="left">Los operadores &quot;&amp;&amp;&quot; y &quot;||&quot; se aplican sobre dos funciones y el operador &quot;!&quot; solo sobre una. Lo mejor de los operadores l&oacute;gicos es que si ponemos dentro de un par de par&eacute;ntesis las funciones con el operador l&oacute;gico, entonces toda la operaci&oacute;n se vuelve una funci&oacute;n booleana, por lo que podemos aplicar m&aacute;s operadores l&oacute;gicos sobre ella. &iquest;No qued&oacute; claro? Revisa estos ejemplos: </p>
      <p align="center">(facingNorth || facingSouth) &amp;&amp; frontIsClear </p>
      <p align="center">(! (frontIsBlocked &amp;&amp; nextToABeeper)) || facingEast </p>
      <p align="center">! (nextToABeeper &amp;&amp; frontIsClear)</p>
      <p align="left">Ten mucho cuidado de colocar bien los par&eacute;ntesis, ya que si no lo haces, no te marcar&aacute; error, pero seguramente har&aacute; algo extra&ntilde;o que tu no quieres que haga.</p>
    </div>
  </div>
</div>
<p>Por ejemplo, si queremos que Karel avance si est&aacute; viendo al norte y el frente est&eacute; libre, podemos hacer lo siguiente:<br />
  ...</p>
<p>if (facingNorth &amp;&amp; frontIsClear) { </p>
<p>&nbsp;&nbsp;&nbsp;move();</p>
<p>}</p>
<p>...</p>
<p>
<b>Ejercicio 3 : </b>   Escribe  un programa de Karel que haga que Karel esté orientado al Norte, desde cualquier dirección inicial, y a continuación se apague. Debería terminar en la misma intersección en la que empezó.</p>
<p>
¿Alguna sugerencia? </p>
<p>
En un mundo nuevo inserta el ejemplo visto arriba para el caso en que Karel est&aacute; orientado hacia el Sur. Pero, &iquest;qu&eacute; ocurre cuando no est&aacute; orientado hacia el Sur?. &iexcl;Podr&iacute;a estar tambi&eacute;n orientado hacia el Norte o el Este !. Entonces necesitas dos sentencias <b>if</b> adicionales, en las cuales se especifique que es lo que debe hacer Karel en esas situaciones. </p>
<p> Modifica el mundo inicial de Karel para probar cualquiera de las 4 direcciones de inicio, y para cada una de ellas vuelve a ejecutar el programa. </p>
<p> En esta secci&oacute;n hemos visto como usar las sentencias de control para adaptar Karel a cada situaci&oacute;n.</p>
<h2><center>
  <p>Condiciones que puede detectar Karel  </p>
  <p align="left"><a href="KarelJAVA.html">Regresar</a> </p>
</center></h2>
</body>
</html>
